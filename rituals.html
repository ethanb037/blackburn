<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Ambient Pulse</title>
  <style>
    /* Modern, Mobile-First Design */
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #121212;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 300px;
      padding: 20px;
    }

    #playButton {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: #4CAF50;
      border: none;
      color: white;
      font-size: 2em;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 30px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      -webkit-appearance: none;
      cursor: pointer;
      transition: transform 0.2s ease, background-color 0.2s ease;
      outline: none;
    }

    #playButton:active {
      transform: scale(0.95);
      background: #3d8b40;
    }

    #sliderContainer {
      width: 100%;
      position: relative;
      padding: 0 10px;
    }

    #frequencySlider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: #333;
      outline: none;
      margin: 10px 0;
    }

    #frequencySlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
      border: 2px solid #333;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    #frequencySlider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
      border: 2px solid #333;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body ontouchstart="">
  <div id="container">
    <button id="playButton" aria-label="Play">▶</button>
    <div id="sliderContainer">
      <input type="range" id="frequencySlider" min="0" max="1" step="0.001" value="0.2">
    </div>
  </div>

  <script>
    // Global State Management
    const state = {
      audioContext: null,
      isPlaying: false,
      currentOscillator: null,
      currentGain: null,
      pulseTimer: null,
      pulseLength: null,
      visibilityPaused: false
    };

    // Generate a consistent pulse length on page load (3-15 seconds)
    state.pulseLength = Math.random() * (15 - 3) + 3;
    
    // Audio Node Pool for reuse
    const nodePool = {
      oscillators: [],
      gains: [],
      // Get oscillator from pool or create new one
      getOscillator: function(context) {
        if (this.oscillators.length > 0) {
          return this.oscillators.pop();
        }
        return context.createOscillator();
      },
      // Get gain node from pool or create new one
      getGain: function(context) {
        if (this.gains.length > 0) {
          return this.gains.pop();
        }
        return context.createGain();
      },
      // Return nodes to pool
      returnNodes: function(osc, gain) {
        if (osc) this.oscillators.push(osc);
        if (gain) this.gains.push(gain);
      }
    };

    // Optimized exponential frequency mapping (100Hz to 15000Hz)
    function calculateFrequency(normalizedValue) {
      // Use a more efficient logarithmic calculation
      if (normalizedValue <= 0.75) {
        return 100 * Math.pow(100, normalizedValue / 0.75);
      } else {
        const factor = (normalizedValue - 0.75) / 0.25;
        return 10000 + factor * 5000;
      }
    }

    // More efficient ADSR implementation with better mobile performance
    function createAndSchedulePulse() {
      if (!state.audioContext || !state.isPlaying) return;
      
      // Clean up previous nodes to prevent memory leaks
      if (state.currentOscillator) {
        try {
          state.currentOscillator.stop();
        } catch (e) {
          // Ignore errors from already stopped oscillators
        }
      }

      // Get frequency value
      const frequencyValue = parseFloat(document.getElementById('frequencySlider').value);
      const frequency = calculateFrequency(frequencyValue);
      
      // Create new audio nodes
      const osc = state.audioContext.createOscillator();
      const gainNode = state.audioContext.createGain();
      
      // Configure oscillator
      osc.type = 'sine';
      osc.frequency.setValueAtTime(frequency, state.audioContext.currentTime);
      
      // Connect nodes
      osc.connect(gainNode);
      gainNode.connect(state.audioContext.destination);
      
      // Precise envelope timing
      const now = state.audioContext.currentTime;
      
      // Start with silence
      gainNode.gain.setValueAtTime(0, now);
      
      // Attack phase - rapid rise
      gainNode.gain.linearRampToValueAtTime(0.8, now + 0.02);
      
      // Decay phase - fall to sustain level
      gainNode.gain.exponentialRampToValueAtTime(0.2, now + 0.3);
      
      // Sustain phase - hold at low level
      gainNode.gain.linearRampToValueAtTime(0.1, now + state.pulseLength - 0.5);
      
      // Release phase - clean rolloff before next pulse
      gainNode.gain.linearRampToValueAtTime(0.001, now + state.pulseLength); // Avoid 0 for exponentialRamp
      
      // Start the oscillator
      osc.start(now);
      
      // Store references
      state.currentOscillator = osc;
      state.currentGain = gainNode;
      
      // Schedule next pulse
      clearTimeout(state.pulseTimer);
      state.pulseTimer = setTimeout(createAndSchedulePulse, state.pulseLength * 1000);
    }

    // Mobile-friendly initialization
    function initializeAudio() {
      // Create new AudioContext if needed
      if (!state.audioContext) {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        state.audioContext = new AudioContext();
      }
      
      // Make sure context is running
      if (state.audioContext.state === 'suspended') {
        state.audioContext.resume();
      }
    }

    // Specialized iOS touch handlers
    function setupIOSAudioSession() {
      // iOS requires user interaction to start audio
      document.addEventListener('touchend', function() {
        if (state.audioContext && state.audioContext.state === 'suspended') {
          state.audioContext.resume();
        }
      }, {once: true});
      
      // Unlock audio on iOS Safari
      window.addEventListener('touchstart', function() {
        if (!state.audioContext) return;
        
        // Play and immediately stop a silent buffer
        const buffer = state.audioContext.createBuffer(1, 1, 22050);
        const source = state.audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(state.audioContext.destination);
        source.start(0);
        source.stop(0);
        
        // Remove this listener once unlocked
        this.removeEventListener('touchstart', arguments.callee);
      }, {once: true, passive: true});
    }

    // Handle visibility changes (tab switching, app background)
    function handleVisibilityChange() {
      if (document.hidden) {
        // Page is hidden - pause audio processing to save battery
        if (state.isPlaying && !state.visibilityPaused) {
          state.visibilityPaused = true;
          clearTimeout(state.pulseTimer);
          
          if (state.audioContext && state.audioContext.state === 'running') {
            state.audioContext.suspend();
          }
        }
      } else {
        // Page is visible again - resume if we were playing
        if (state.isPlaying && state.visibilityPaused) {
          state.visibilityPaused = false;
          
          if (state.audioContext) {
            state.audioContext.resume().then(() => {
              createAndSchedulePulse();
            });
          }
        }
      }
    }

    // Toggle play/pause state
    function togglePlay() {
      if (!state.isPlaying) {
        // Start playing
        initializeAudio();
        state.isPlaying = true;
        document.getElementById('playButton').textContent = '⏹';
        createAndSchedulePulse();
      } else {
        // Stop playing
        state.isPlaying = false;
        document.getElementById('playButton').textContent = '▶';
        clearTimeout(state.pulseTimer);
        
        if (state.currentOscillator) {
          const now = state.audioContext.currentTime;
          // Fade out gracefully
          state.currentGain.gain.cancelScheduledValues(now);
          state.currentGain.gain.setValueAtTime(state.currentGain.gain.value, now);
          state.currentGain.gain.linearRampToValueAtTime(0, now + 0.1);
          
          // Stop after fade
          setTimeout(() => {
            if (state.currentOscillator) {
              try {
                state.currentOscillator.stop();
              } catch (e) {
                // Ignore errors if already stopped
              }
              state.currentOscillator = null;
              state.currentGain = null;
            }
          }, 150);
        }
      }
    }

    // Set up event listeners when document is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Play button event handlers for both mobile and desktop
      const playButton = document.getElementById('playButton');
      
      // Handle click events (desktop)
      playButton.addEventListener('click', function(e) {
        e.preventDefault();
        togglePlay();
      });
      
      // Handle touch events (mobile)
      playButton.addEventListener('touchend', function(e) {
        e.preventDefault();
        togglePlay();
        // Prevent double-firing on devices that trigger both touch and click
        e.stopPropagation();
      }, {passive: false});
      
      // Frequency slider changes
      const frequencySlider = document.getElementById('frequencySlider');
      
      ['input', 'change'].forEach(function(evt) {
        frequencySlider.addEventListener(evt, function() {
          if (state.isPlaying && state.currentOscillator) {
            const frequencyValue = parseFloat(this.value);
            const frequency = calculateFrequency(frequencyValue);
            
            // Update frequency with proper ramp to avoid glitches
            const now = state.audioContext.currentTime;
            state.currentOscillator.frequency.cancelScheduledValues(now);
            state.currentOscillator.frequency.setValueAtTime(state.currentOscillator.frequency.value, now);
            state.currentOscillator.frequency.exponentialRampToValueAtTime(frequency, now + 0.05);
          }
        });
      });
      
      // Page visibility handling for battery optimization
      document.addEventListener('visibilitychange', handleVisibilityChange);
      
      // Setup iOS-specific audio session
      setupIOSAudioSession();
      
      // Prevent touch scrolling/zooming issues
      document.addEventListener('touchmove', function(e) {
        if (e.target.id === 'frequencySlider') {
          e.stopPropagation();
        }
      }, {passive: true});
    });

    // Handle page unload to clean up resources
    window.addEventListener('beforeunload', function() {
      if (state.audioContext) {
        clearTimeout(state.pulseTimer);
        if (state.currentOscillator) {
          try {
            state.currentOscillator.stop();
          } catch (e) {
            // Ignore errors
          }
        }
        state.audioContext.close();
      }
    });
  </script>
</body>
</html>
