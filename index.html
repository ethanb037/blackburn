<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ars culus™ | TRANSCENDENT RITUAL</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Times New Roman', serif;
            cursor: url('paintbrush.cur'), auto;
            background: #000;
        }
        
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        #portal-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        
        #portal {
            background: url('assets/backgrounds/marble.jpg');
            border: 3px double black;
            padding: 20px;
            width: 80%;
            max-width: 600px;
            box-shadow: 8px 8px 0px #888;
            text-align: center;
            pointer-events: auto;
            transform: rotate(-1deg);
            transition: transform 0.5s;
        }
        
        #portal:hover {
            transform: rotate(1deg);
        }
        
        .handwritten {
            border: 2px groove black;
            padding: 10px;
            background: white;
            margin: 20px auto;
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            font-family: Courier, monospace;
            background: url('assets/backgrounds/marble.gif');
        }
        
        .paint-button {
            background: white;
            border: 3px outset black;
            padding: 5px 15px;
            font-size: 14px;
            cursor: pointer;
            margin: 10px;
            font-family: 'Comic Sans MS', cursive;
            position: relative;
            overflow: hidden;
        }
        
        .paint-button::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: rgba(255,255,255,0.2);
            transform: rotate(30deg);
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
        }
        
        .paint-button:hover::after {
            opacity: 1;
            transform: rotate(30deg) translate(-30%, -30%);
        }
        
        .paint-button:hover {
            border: 3px inset black;
            background: #EEE;
        }
        
        .big-button {
            background: white;
            border: 10px outset black;
            padding: 10px 25px;
            font-size: 25px;
            cursor: pointer;
            margin: 10px;
            font-family: 'Comic Sans MS', bold;
            animation: pulse 2s infinite;
            position: relative;
            overflow: hidden;
        }
        
        .big-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 3s infinite;
        }
        
        @keyframes shine {
            0% { left: -100%; }
            20% { left: 100%; }
            100% { left: 100%; }
        }
        
        .big-button:hover {
            border: 10px inset black;
            background: #EEE;
            animation: none;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .marquee {
            width: 100%;
            background: black;
            color: white;
            padding: 5px 0;
            font-family: Arial;
        }
        
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 14px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            z-index: 2;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
        }
        
        #timer {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            font-size: 20px;
            text-shadow: 0 0 5px #ffffff;
            z-index: 2;
            font-family: monospace;
        }
        
        #manifesto-scroll {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            width: 50%;
            text-shadow: 0 0 5px #ffffff;
            z-index: 2;
            font-family: 'Times New Roman', serif;
            overflow: hidden;
            height: 80px;
            padding: 5px;
            background: rgba(0,0,0,0.3);
            border-left: 1px solid rgba(255,255,255,0.2);
        }
        
        .floating-text {
            position: absolute;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Times New Roman', serif;
            pointer-events: none;
            white-space: nowrap;
            z-index: 3;
            mix-blend-mode: difference;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            z-index: 100;
            font-family: 'Courier New', monospace;
        }
        
        #loading-bar {
            width: 300px;
            height: 20px;
            border: 2px solid white;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }
        
        #loading-progress {
            height: 100%;
            background: white;
            width: 0%;
            transition: width 0.5s;
            position: relative;
        }
        
        #loading-progress::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
            animation: loading-shine 1.5s infinite;
        }
        
        @keyframes loading-shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .hidden {
            display: none !important;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 12px;
            z-index: 2;
            font-family: 'Courier New', monospace;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        #controls:hover {
            opacity: 1;
        }
        
        #return-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 5px 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            z-index: 20;
            opacity: 0.5;
            transition: opacity 0.3s;
        }
        
        #return-button:hover {
            opacity: 1;
        }
        
        .glitch {
            animation: glitch-anim 0.3s infinite;
        }
        
        @keyframes glitch-anim {
            0% { opacity: 1; transform: translate(0); }
            20% { opacity: 1; transform: translate(-5px, 5px); }
            40% { opacity: 1; transform: translate(5px, -5px); }
            60% { opacity: 1; transform: translate(-5px, -5px); }
            80% { opacity: 1; transform: translate(5px, 5px); }
            100% { opacity: 1; transform: translate(0); }
        }
        
        #visual-effects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.3;
        }
        
        .ritual-symbol {
            position: fixed;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 3s;
            pointer-events: none;
            z-index: 4;
        }
        
        #about-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white url('assets/backgrounds/marble.jpg');
            border: 3px double black;
            padding: 20px;
            max-width: 500px;
            z-index: 100;
            box-shadow: 10px 10px 0px #555;
        }
        
        #about-link {
            position: fixed;
            bottom: 10px;
            left: 10px;
            font-family: 'Times New Roman';
            font-size: 12px;
            color: rgba(255,255,255,0.3);
            z-index: 5;
            cursor: pointer;
        }
        
        #audio-controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 5;
            display: flex;
            gap: 5px;
        }
        
        .audio-button {
            background: rgba(0,0,0,0.5);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 5px;
            font-size: 12px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s, transform 0.2s;
        }
        
        .audio-button:hover {
            opacity: 1;
            transform: scale(1.05);
        }
        
        #credits {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            opacity: 0;
            transition: opacity 3s;
            pointer-events: none;
        }
        
        #text-portal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-family: 'Courier New', monospace;
            padding: 20px;
            overflow-y: auto;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        #text-portal.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        #text-portal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }
        
        .text-portal-entry {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .text-portal-entry h3 {
            color: #ccccff;
            margin-bottom: 5px;
        }
        
        .text-portal-entry p {
            margin-top: 5px;
            line-height: 1.5;
        }
        
        #sound-visualizer {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 60px;
            z-index: 4;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loading">
        <h2>ars culus™ RITUAL INITIALIZING</h2>
        <p>Rejecting binary oppositions...</p>
        <div id="loading-bar">
            <div id="loading-progress"></div>
        </div>
    </div>

    <canvas id="visual-effects"></canvas>
    <div id="info">ARS CULUS - TRANSCENDENT RITUAL PILGRIMAGE</div>
    <div id="timer">00:00:00 / 72:00:00</div>
    <div id="manifesto-scroll"></div>
    <div id="controls">PRESS: [1] Orbit View [2] Ethan Focus [3] Noel Focus [ESC] Return to Portal</div>
    <button id="return-button" class="hidden">RETURN TO PORTAL</button>
    <canvas id="sound-visualizer"></canvas>
    
    <div id="portal-container" class="hidden">
        <div id="portal">
            <img src="under_construction.gif" alt="">
            <h1 style="text-shadow: 3px 3px 0px #CCC">ars culus<br>♻♻⍋⍺⑬</h1>
            
            <div class="handwritten">
                <p><em>"you've known for a while now.."</em></p>
                <marquee behavior="scroll" direction="left">The ritual begins when you reject binary oppositions, install our toolbar, fax your signature, breathe into the monitor. Now.</marquee>
            </div>
            
            <button class="paint-button" id="ethan-button">SUMMON ETHAN</button>
            <button class="paint-button" id="noel-button">SUMMON NOEL</button>
            <br>
            <button class="big-button" id="enter-ritual">ENTER THE 72 HOUR RITUAL</button>
            
            <div style="border-left:10px solid black; padding-left:10px; margin:20px; text-align: left;">
                <p>"Ars Culus represents the pinnacle of applied phenomenology. basically, we mean"<br>
                <a href="#" style="color:blue; text-decoration:none">Dr. M.B.S. Johnson</a><br>
                <font size="1">(Journal of Neo-Anachronistic Studies, 1997)</font></p>
            </div>
            
            <div style="margin-top: 30px; font-size: 10px; color: #666; border-top: 1px dashed #999; padding-top: 10px;">
                <img src="netscape.gif" width="88" height="31" alt="Netscape Now!" style="vertical-align: middle; margin-right: 10px;">
                <img src="midi.gif" width="88" height="31" alt="MIDI Enabled" style="vertical-align: middle;">
                <br>
                Requires Macromedia Shockwave® plugin & RealPlayer® 2.0<br>
                Best viewed at 800x600 resolution
            </div>
            
            <!-- Visitor counter -->
            <div style="margin-top: 15px; border: 1px solid #999; display: inline-block; padding: 5px; background: #eee;">
                <span style="font-family: Verdana; font-size: 10px;">VISITORS:</span>
                <span style="font-family: 'Courier New'; background: black; color: #33ff33; padding: 2px 5px;">000731</span>
            </div>
            
            <!-- Webring badges -->
            <div style="margin-top: 20px;">
                <img src="assets/badges/netscape.gif" width="88" height="31" alt="Netscape Now!" style="margin: 0 5px;">
                <img src="assets/badges/valid-html.gif" width="88" height="31" alt="Valid HTML" style="margin: 0 5px;">
                <img src="midi-enabled.gif" width="88" height="31" alt="MIDI Enabled" style="margin: 0 5px;">
                <img src="best-viewed.gif" width="88" height="31" alt="Best Viewed 800x600" style="margin: 0 5px;">
            </div>
            
            <!-- Footer -->
            <div style="margin-top: 30px; font-size: 10px; color: #666; border-top: 1px dashed #999; padding-top: 10px;">
                <p>© 1997-202X ars culus™ | All Rights Reserved and Simultaneously Rejected</p>
                <a href="#" style="color: blue; text-decoration: none; font-family: Verdana; font-size: 10px;">
                    <img src="book.gif" width="16" height="16" style="vertical-align: middle; margin-right: 5px;">SIGN OUR GUESTBOOK
                </a>
            </div>
        </div>
    </div>

    <!-- About panel -->
    <div id="about-panel">
        <h2 style="text-align: center; margin-top: 0;">About ars culus™</h2>
        
        <p>ars culus is a hot air balloon tour agency masquerading as an art collective that is pretending to be a funk/pop duo in the 70s imagining what music would sound like in 2019 which is an auspicious year for them because they were recently expelled from Brazil.</p>
        
        <p>The collective is primarily composed of V Noel and Ethan Blackburn, who use sound as a vice to enter(tain) others. Most recently they showcased a week-long artistic takeover in a curious bookstore in Maastricht as well as many rituals composed of smaller rituals.</p>
        
        <p>We assemble to disseminate paradoxical paradigms that catalyze statistical convergence towards symbiotic synergy.</p>
        
        <div style="text-align: center; margin-top: 20px;">
            <button onclick="document.getElementById('about-panel').style.display='none';" style="font-family: 'Times New Roman'; padding: 5px 15px; cursor: pointer;">CLOSE</button>
        </div>
    </div>

    <!-- About link -->
    <div id="about-link">about</div>

    <!-- Audio controls -->
    <div id="audio-controls" style="display: none;">
        <button id="toggle-sound" class="audio-button" data-sound-enabled="true">
            <span id="sound-icon">🔊</span>
        </button>
        <button id="ambient-sound" class="audio-button">🌊 Ambient</button>
        <button id="ritual-sound" class="audio-button">🔮 Ritual</button>
        <button id="cosmic-sound" class="audio-button">✨ Cosmic</button>
    </div>

    <!-- Ritual symbols -->
    <div id="ritual-artifacts" class="hidden">
        <div class="ritual-symbol" style="top: 70%; left: 15%; transform: translate(-50%, -50%) rotate(15deg);">
            <img src="symbol1.gif" width="40" height="40" alt="">
        </div>
        
        <div class="ritual-symbol" style="top: 30%; left: 80%; transform: translate(-50%, -50%) rotate(-10deg);">
            <img src="symbol2.gif" width="40" height="40" alt="">
        </div>
        
        <div class="ritual-symbol" style="top: 20%; left: 25%; transform: translate(-50%, -50%) rotate(5deg);">
            <img src="symbol3.gif" width="40" height="40" alt="">
        </div>
    </div>

    <!-- Text Portal -->
    <div id="text-portal">
        <button id="text-portal-close">×</button>
        <h2>TRANSCENDENT COMMUNICATIONS</h2>
        
        <div class="text-portal-entry">
            <h3>RITUAL OBSERVATION #1</h3>
            <p>The art worker shall create. The art worker shall enable creation. The art worker shall resist discrimination. The art worker shall resist idolization.</p>
            <p>We have observed that when binary oppositions are rejected, new pathways emerge through the liminal spaces between conventional categorizations.</p>
        </div>
        
        <div class="text-portal-entry">
            <h3>RITUAL OBSERVATION #2</h3>
            <p>How things endure? How absence speaks? How habits know themself? How does the radio know when you're finally learning the lyrics?</p>
            <p>The ritual participants report experiencing a dissolution of boundaries between self and other, between creator and creation.</p>
        </div>
        
        <div class="text-portal-entry">
            <h3>TRANSMISSION FROM V NOEL</h3>
            <p>We assemble to disseminate paradoxical paradigms that catalyze statistical convergence towards symbiotic synergy.</p>
            <p>The question is not whether something is art, but how it functions as art within specific contexts and relations.</p>
        </div>
        
        <div class="text-portal-entry">
            <h3>TRANSMISSION FROM ETHAN BLACKBURN</h3>
            <p>How to touch without touching? How to face and facing? How when they never were over?</p>
            <p>The ritual continues even when you believe it has ended. The 72 hours are both literal and metaphorical.</p>
        </div>
        
        <div class="text-portal-entry">
            <h3>RITUAL DOCUMENTATION</h3>
            <p>Participants report seeing themselves from outside during the third phase of the ritual. This phenomenon appears to correlate with the rejection of conventional subject/object distinctions.</p>
            <p>We have documented 731 successful completions of the ritual since its inception in 1997.</p>
        </div>
    </div>

    <!-- Credits -->
    <div id="credits">
        <div style="text-align: center; color: white; font-family: 'Times New Roman', serif; max-width: 600px;">
            <h2 style="margin-bottom: 50px;">ars culus™</h2>
            
            <p style="margin: 30px 0;">A TRANSCENDENT RITUAL</p>
            
            <p style="margin: 30px 0;">Created by<br>V NOEL & ETHAN BLACKBURN</p>
            
            <p style="margin: 30px 0;">The art worker shall create.<br>The art worker shall love.</p>
            
            <p style="margin: 50px 0;">Thank you for participating in the ritual.</p>
        </div>
    </div>

    <!-- Page transition -->
    <div id="page-transition" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; opacity: 1; transition: opacity 1s; z-index: 9999; pointer-events: none;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Core application state
        const AppState = {
            ritualActive: false,
            elapsedTime: 0,
            cameraMode: 'orbit',
            cameraTransitioning: false,
            cameraTweenProgress: 0,
            particlePool: [],
            textPool: [],
            loadingProgress: 0,
            manifestoPosition: 0,
            audioInitialized: false,
            qualityLevel: 2, // 1=low, 2=medium, 3=high
            previousFrameTime: 0,
            frameRate: 60,
            frameCount: 0,
            lastFpsUpdate: 0,
            soundMode: 'ambient', // ambient, ritual, cosmic
            textPortalActive: false,
            interactiveElements: [],
            clickSoundEnabled: true
        };

        // Manifesto text
        const manifestoText = `
How things endure? How things begin? How absence speaks? How habits know themself? How does the radio know when you're finally learning the lyrics? How does an unnoticed maintain its membership? How does a key know its teeth? How does the shelf know its edge? How does the hook carry itself? how can coming come? how sitting sits? how does melting melts melted? How might a wall count its cracks? How does a door know the impatient? How when a word book refuses to contain containing which it promised to contain? How will do I close covers? How do I read upside down? How might a clock, a streetlight? How do I say something without repeating anyone else? How will repetition hold me? How will others know me? How is it possible that certain objects or places appear, over extended observation, to cultivate a richness, significance and an almost animate presence as the possibility for meaningful human interaction, to those same observers, slowly and increasingly disappear and turns instead towards zero? How if meaning decides to take an unauthorized vacation from its meaning-duties? How do inanimate people remain living? How do I read lips? How to make without thinking? How weight grounds? How to know noise? How to distinguish approach of realization? How do I know absence? How when numbers number a little too much and start to letter? How are moments linked together? How to grow without knowing? How a child and his dog? How will feeling be felt? How will things change once they're understood as over? How when color refuses to maintain its chromatic responsibilities? When volume asserts loud to wide and wide to loud confusing its cubic sense of self with a probable disconnected sense of spatial significance, but that they may never meet and be known as occupations of two different sized spaces to another? How if Sunday doesn't show proper affection to Monday? How when four birds are precisely not four but also not quite three? How when they never were over? How when this necessitates the absence of birthed and repressed sentiment to be privatized in your own language before you recall its significance at the end of this sentence? How if an alphabet reputes itself without consulting proper alphabetical authority? How light remembers? How does structure structure structurally structuring structured structures? How endings begin? How to fragment a unity? How when collecting embarks on training to assert itself as a lifestyle, but targets the wrong verbal audience? How to hear silent now? How a line can curve? How a wind can move? How redness is how it is? How to make is doing to be but how to approach? How it will be, when it is how to see, when is how now gone here when so much nothing to become? How to touch without touching? How to face and facing?

diktat of the art worker.
the art worker… 

shall create.

shall enable creation.

shall resist discrimination.

shall resist idolization. 

shall submit.

shall sublimate.

shall sublate.

shall collaborate.

shall assimilate.

works for no one.

is of every one.

shall love.

We want to tell people that there is more than one way of knowing.
Ars Culus Is a collectism-driven enterprise that covers themes of relativistic politics in the consumed. 
To simplify, we assemble to disseminate paradoxical paradigms that catalyze statistical convergence towards symbiotic synergy.
As in, we want to question why is something art or not.
`;

        // Loading messages
        const loadingMessages = [
            "Rejecting binary oppositions...",
            "Installing toolbar...",
            "Faxing signature...",
            "Breathing into monitor...",
            "Sublimating digital consciousness...",
            "Structuring structurally structuring structured structures...",
            "Enabling creation...",
            "Resisting idolization...",
            "Submitting...",
            "Sublating..."
        ];

        // DOM Elements
        const elements = {
            loading: document.getElementById('loading'),
            loadingProgress: document.getElementById('loading-progress'),
            portalContainer: document.getElementById('portal-container'),
            returnButton: document.getElementById('return-button'),
            controls: document.getElementById('controls'),
            timer: document.getElementById('timer'),
            manifestoScroll: document.getElementById('manifesto-scroll'),
            visualEffects: document.getElementById('visual-effects'),
            pageTransition: document.getElementById('page-transition'),
            ritualArtifacts: document.getElementById('ritual-artifacts'),
            aboutLink: document.getElementById('about-link'),
            aboutPanel: document.getElementById('about-panel'),
            toggleSound: document.getElementById('toggle-sound'),
            audioControls: document.getElementById('audio-controls'),
            credits: document.getElementById('credits'),
            textPortal: document.getElementById('text-portal'),
            textPortalClose: document.getElementById('text-portal-close'),
            soundVisualizer: document.getElementById('sound-visualizer')
        };

        // Initialize visual effects canvas
        const effectsCanvas = document.getElementById('visual-effects');
        const effectsCtx = effectsCanvas.getContext('2d');
        
        // Initialize sound visualizer
        const visualizerCanvas = document.getElementById('sound-visualizer');
        const visualizerCtx = visualizerCanvas.getContext('2d');
        
        function resizeCanvases() {
            effectsCanvas.width = window.innerWidth;
            effectsCanvas.height = window.innerHeight;
            
            visualizerCanvas.width = 200;
            visualizerCanvas.height = 60;
        }
        
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Simulate loading with improved performance
        function simulateLoading() {
            let interval = null;
            
            function updateLoading() {
                AppState.loadingProgress += Math.random() * 5;
                
                if (AppState.loadingProgress >= 100) {
                    AppState.loadingProgress = 100;
                    clearInterval(interval);
                    
                    setTimeout(() => {
                        elements.loading.classList.add('hidden');
                        elements.portalContainer.classList.remove('hidden');
                    }, 1000);
                }
                
                elements.loadingProgress.style.width = `${AppState.loadingProgress}%`;
                
                // Update loading message
                const messageIndex = Math.floor((AppState.loadingProgress / 100) * loadingMessages.length);
                document.querySelector('#loading p').textContent = 
                    loadingMessages[Math.min(messageIndex, loadingMessages.length - 1)];
            }
            
            interval = setInterval(updateLoading, 300);
        }

        // Initialize loading simulation
        simulateLoading();

        // Update manifesto scroll with throttling
        function updateManifestoScroll() {
            const chunk = manifestoText.substring(AppState.manifestoPosition, AppState.manifestoPosition + 100);
            elements.manifestoScroll.innerHTML = chunk;
            AppState.manifestoPosition = (AppState.manifestoPosition + 1) % (manifestoText.length - 100);
        }

        // Throttled manifesto update
        setInterval(updateManifestoScroll, 150);

        // Audio system - enhanced with interactive soundscapes
        const AudioSystem = {
            context: null,
            masterGain: null,
            analyser: null,
            analyserData: null,
            oscillators: [],
            noiseNodes: [],
            currentSoundscape: null,
            
            initialize() {
                if (this.context) return;
                
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.context.createGain();
                    this.masterGain.gain.value = 0.5;
                    this.masterGain.connect(this.context.destination);
                    
                    // Create analyzer for visualizations
                    this.analyser = this.context.createAnalyser();
                    this.analyser.fftSize = 256;
                    this.analyserData = new Uint8Array(this.analyser.frequencyBinCount);
                    this.masterGain.connect(this.analyser);
                    
                    AppState.audioInitialized = true;
                    
                    // Show visualizer
                    elements.soundVisualizer.style.opacity = '1';
                    
                    // Start visualization
                    this.visualize();
                } catch (e) {
                    console.log('Audio initialization failed:', e);
                }
            },
            
            visualize() {
                if (!this.analyser) return;
                
                const draw = () => {
                    if (!AppState.ritualActive) {
                        requestAnimationFrame(draw);
                        return;
                    }
                    
                    // Get frequency data
                    this.analyser.getByteFrequencyData(this.analyserData);
                    
                    // Clear canvas
                    visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                    
                    // Draw background
                    visualizerCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    visualizerCtx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                    
                    // Calculate bar width
                    const barWidth = (visualizerCanvas.width / this.analyserData.length) * 2.5;
                    let barHeight;
                    let x = 0;
                    
                    // Draw bars
                    for (let i = 0; i < this.analyserData.length; i++) {
                        barHeight = this.analyserData[i] / 2;
                        
                        // Color based on current soundscape
                        let hue;
                        switch (AppState.soundMode) {
                            case 'ambient': hue = 200; break; // Blue
                            case 'ritual': hue = 280; break;  // Purple
                            case 'cosmic': hue = 30; break;   // Gold
                            default: hue = 200;
                        }
                        
                        visualizerCtx.fillStyle = `hsla(${hue}, 80%, ${50 + barHeight/3}%, 0.8)`;
                        visualizerCtx.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);
                        
                        x += barWidth + 1;
                    }
                    
                    requestAnimationFrame(draw);
                };
                
                draw();
            },
            
            toggleMute() {
                if (!this.context) return;
                
                if (this.context.state === 'running') {
                    this.context.suspend();
                    return false;
                } else {
                    this.context.resume();
                    return true;
                }
            },
            
            stopAllSounds() {
                // Stop all oscillators
                this.oscillators.forEach(osc => {
                    try {
                        osc.stop();
                        osc.disconnect();
                    } catch (e) {}
                });
                this.oscillators = [];
                
                // Stop all noise nodes
                this.noiseNodes.forEach(node => {
                    try {
                        if (node.gain) node.gain.value = 0;
                    } catch (e) {}
                });
                this.noiseNodes = [];
                
                // Stop current soundscape
                if (this.currentSoundscape) {
                    clearInterval(this.currentSoundscape);
                    this.currentSoundscape = null;
                }
            },
            
            createAmbientSoundscape() {
                this.stopAllSounds();
                AppState.soundMode = 'ambient';
                
                // Create drone sounds
                const baseFrequencies = [55, 110, 165, 220];
                
                baseFrequencies.forEach((freq, index) => {
                    const oscillator = this.context.createOscillator();
                    oscillator.type = index % 2 === 0 ? 'sine' : 'triangle';
                    oscillator.frequency.value = freq;
                    oscillator.detune.value = Math.random() * 10 - 5;
                    
                    const gainNode = this.context.createGain();
                    gainNode.gain.value = 0;
                    
                    // Create filter for warmth
                    const filter = this.context.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 1000;
                    filter.Q.value = 1;
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(filter);
                    filter.connect(this.masterGain);
                    
                    oscillator.start();
                    this.oscillators.push(oscillator);
                    
                    // Fade in
                    gainNode.gain.linearRampToValueAtTime(
                        0.1 / (index + 1),
                        this.context.currentTime + 2
                    );
                });
                
                // Add water sounds
                const waterNoise = this.createNoise();
                const waterGain = this.context.createGain();
                waterGain.gain.value = 0;
                
                // Create bandpass filter for water sound
                const waterFilter = this.context.createBiquadFilter();
                waterFilter.type = 'bandpass';
                waterFilter.frequency.value = 500;
                waterFilter.Q.value = 0.7;
                
                waterNoise.connect(waterFilter);
                waterFilter.connect(waterGain);
                waterGain.connect(this.masterGain);
                
                // Fade in water sound
                waterGain.gain.linearRampToValueAtTime(0.05, this.context.currentTime + 3);
                
                this.noiseNodes.push(waterGain);
                
                // Schedule random tones
                this.currentSoundscape = setInterval(() => {
                    if (Math.random() < 0.3) {
                        this.playRandomTone('ambient');
                    }
                }, 8000);
            },
            
            createRitualSoundscape() {
                this.stopAllSounds();
                AppState.soundMode = 'ritual';
                
                // Create ritual drums
                const rhythmInterval = 2; // seconds
                const beatPatterns = [
                    [1, 0, 0, 1, 0, 1, 0, 0],
                    [1, 0, 1, 0, 1, 0, 0, 1]
                ];
                
                let currentBeat = 0;
                let currentPattern = 0;
                
                // Create drum sound function
                const playDrumSound = (pitch = 100, decay = 0.3) => {
                    const drumOsc = this.context.createOscillator();
                    drumOsc.type = 'triangle';
                    drumOsc.frequency.value = pitch;
                    
                    const drumGain = this.context.createGain();
                    drumGain.gain.value = 0.2;
                    
                    // Quick attack, fast decay
                    drumGain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + decay);
                    
                    drumOsc.connect(drumGain);
                    drumGain.connect(this.masterGain);
                    
                    drumOsc.start();
                    drumOsc.stop(this.context.currentTime + decay);
                };
                
                // Create ritual atmosphere
                const ritualDrone = this.context.createOscillator();
                ritualDrone.type = 'sawtooth';
                ritualDrone.frequency.value = 55;
                
                const ritualFilter = this.context.createBiquadFilter();
                ritualFilter.type = 'lowpass';
                ritualFilter.frequency.value = 300;
                
                const ritualGain = this.context.createGain();
                ritualGain.gain.value = 0;
                
                ritualDrone.connect(ritualFilter);
                ritualFilter.connect(ritualGain);
                ritualGain.connect(this.masterGain);
                
                ritualDrone.start();
                this.oscillators.push(ritualDrone);
                
                // Fade in drone
                ritualGain.gain.linearRampToValueAtTime(0.1, this.context.currentTime + 2);
                
                // Add ritual chants
                const chantFrequencies = [220, 275, 330, 440];
                
                chantFrequencies.forEach((freq, index) => {
                    setTimeout(() => {
                        const chantOsc = this.context.createOscillator();
                        chantOsc.type = 'sine';
                        chantOsc.frequency.value = freq;
                        
                        const chantGain = this.context.createGain();
                        chantGain.gain.value = 0;
                        
                        chantOsc.connect(chantGain);
                        chantGain.connect(this.masterGain);
                        
                        chantOsc.start();
                        this.oscillators.push(chantOsc);
                        
                        // Fade in and pulse
                        chantGain.gain.linearRampToValueAtTime(0.05, this.context.currentTime + 1);
                        
                        // Create LFO for pulsing
                        const lfo = this.context.createOscillator();
                        lfo.type = 'sine';
                        lfo.frequency.value = 0.1 + index * 0.05;
                        
                        const lfoGain = this.context.createGain();
                        lfoGain.gain.value = 0.03;
                        
                        lfo.connect(lfoGain);
                        lfoGain.connect(chantGain.gain);
                        
                        lfo.start();
                        this.oscillators.push(lfo);
                    }, index * 1000);
                });
                
                // Start ritual rhythm
                this.currentSoundscape = setInterval(() => {
                    const pattern = beatPatterns[currentPattern];
                    if (pattern[currentBeat]) {
                        if (currentBeat === 0) {
                            playDrumSound(80, 0.5); // Low drum
                        } else {
                            playDrumSound(120, 0.2); // Higher drum
                        }
                    }
                    
                    currentBeat = (currentBeat + 1) % pattern.length;
                    
                    // Occasionally change pattern
                    if (currentBeat === 0 && Math.random() < 0.2) {
                        currentPattern = (currentPattern + 1) % beatPatterns.length;
                    }
                }, (rhythmInterval * 1000) / 8);
            },
            
            createCosmicSoundscape() {
                this.stopAllSounds();
                AppState.soundMode = 'cosmic';
                
                // Create shimmering background
                const shimmerNoise = this.createNoise();
                const shimmerGain = this.context.createGain();
                shimmerGain.gain.value = 0;
                
                // Create highpass filter for cosmic shimmer
                const shimmerFilter = this.context.createBiquadFilter();
                shimmerFilter.type = 'highpass';
                shimmerFilter.frequency.value = 3000;
                
                shimmerNoise.connect(shimmerFilter);
                shimmerFilter.connect(shimmerGain);
                shimmerGain.connect(this.masterGain);
                
                // Fade in shimmer
                shimmerGain.gain.linearRampToValueAtTime(0.03, this.context.currentTime + 2);
                
                this.noiseNodes.push(shimmerGain);
                
                // Create cosmic tones
                const cosmicFrequencies = [
                    220 * Math.pow(2, 7/12),  // F#
                    220 * Math.pow(2, 11/12), // B
                    220 * 2 * Math.pow(2, 2/12), // D
                    220 * 2 * Math.pow(2, 7/12)  // F# octave up
                ];
                
                cosmicFrequencies.forEach((freq, index) => {
                    setTimeout(() => {
                        const cosmicOsc = this.context.createOscillator();
                        cosmicOsc.type = 'sine';
                        cosmicOsc.frequency.value = freq;
                        
                        const cosmicGain = this.context.createGain();
                        cosmicGain.gain.value = 0;
                        
                        // Add reverb
                        const convolver = this.createReverb(3);
                        
                        cosmicOsc.connect(cosmicGain);
                        cosmicGain.connect(convolver);
                        convolver.connect(this.masterGain);
                        
                        cosmicOsc.start();
                        this.oscillators.push(cosmicOsc);
                        
                        // Fade in with long attack
                        cosmicGain.gain.linearRampToValueAtTime(0.07, this.context.currentTime + 3);
                        
                        // Subtle vibrato
                        const vibrato = this.context.createOscillator();
                        vibrato.type = 'sine';
                        vibrato.frequency.value = 5 + Math.random() * 3;
                        
                        const vibratoGain = this.context.createGain();
                        vibratoGain.gain.value = 2 + Math.random() * 2;
                        
                        vibrato.connect(vibratoGain);
                        vibratoGain.connect(cosmicOsc.detune);
                        
                        vibrato.start();
                        this.oscillators.push(vibrato);
                    }, index * 1500);
                });
                
                // Schedule random cosmic events
                this.currentSoundscape = setInterval(() => {
                    if (Math.random() < 0.4) {
                        this.playRandomTone('cosmic');
                    }
                }, 6000);
            },
            
            createNoise() {
                const bufferSize = 2 * this.context.sampleRate;
                const noiseBuffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noise = this.context.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.loop = true;
                noise.start();
                
                return noise;
            },
            
            createReverb(duration = 2) {
                const convolver = this.context.createConvolver();
                const rate = this.context.sampleRate;
                const length = rate * duration;
                const impulse = this.context.createBuffer(2, length, rate);
                
                const leftChannel = impulse.getChannelData(0);
                const rightChannel = impulse.getChannelData(1);
                
                for (let i = 0; i < length; i++) {
                    const n = i / length;
                    // Decay curve
                    const value = (1 - n) * Math.random() * 0.5;
                    leftChannel[i] = value;
                    rightChannel[i] = value;
                }
                
                convolver.buffer = impulse;
                return convolver;
            },
            
            playRandomTone(type = 'ambient') {
                if (!this.context) return;
                
                const now = this.context.currentTime;
                
                // Create oscillator
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                // Set parameters based on soundscape type
                let noteBase, noteOffset, oscillatorType, attack, decay, maxGain;
                
                switch (type) {
                    case 'ambient':
                        noteBase = [110, 146.83, 165, 220][Math.floor(Math.random() * 4)];
                        noteOffset = [0, 2, 4, 7, 9][Math.floor(Math.random() * 5)];
                        oscillatorType = ['sine', 'triangle'][Math.floor(Math.random() * 2)];
                        attack = 0.2;
                        decay = 3 + Math.random() * 2;
                        maxGain = 0.1;
                        break;
                    case 'ritual':
                        noteBase = [82.41, 110, 146.83][Math.floor(Math.random() * 3)];
                        noteOffset = [0, 3, 7, 10][Math.floor(Math.random() * 4)];
                        oscillatorType = ['triangle', 'square'][Math.floor(Math.random() * 2)];
                        attack = 0.1;
                        decay = 1 + Math.random() * 1;
                        maxGain = 0.15;
                        break;
                    case 'cosmic':
                        noteBase = [220, 277.18, 329.63][Math.floor(Math.random() * 3)];
                        noteOffset = [0, 4, 7, 11][Math.floor(Math.random() * 4)];
                        oscillatorType = 'sine';
                        attack = 0.5;
                        decay = 4 + Math.random() * 3;
                        maxGain = 0.08;
                        break;
                    default:
                        noteBase = 220;
                        noteOffset = 0;
                        oscillatorType = 'sine';
                        attack = 0.2;
                        decay = 2;
                        maxGain = 0.1;
                }
                
                const frequency = noteBase * Math.pow(2, noteOffset / 12);
                
                oscillator.type = oscillatorType;
                oscillator.frequency.value = frequency;
                
                // Envelope
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(maxGain, now + attack);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + attack + decay);
                
                // Add effects based on type
                if (type === 'cosmic') {
                    // Add reverb for cosmic sounds
                    const reverb = this.createReverb(5);
                    oscillator.connect(gainNode);
                    gainNode.connect(reverb);
                    reverb.connect(this.masterGain);
                } else {
                    // Direct connection for other sounds
                    oscillator.connect(gainNode);
                    gainNode.connect(this.masterGain);
                }
                
                // Start and stop
                oscillator.start(now);
                oscillator.stop(now + attack + decay);
            },
            
            playClickSound(x, y) {
                if (!this.context || !AppState.clickSoundEnabled) return;
                
                const now = this.context.currentTime;
                
                // Create oscillator
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                // Map x position to frequency (left = lower, right = higher)
                const normalizedX = x / window.innerWidth;
                const frequency = 220 + normalizedX * 440;
                
                // Map y position to decay (top = shorter, bottom = longer)
                const normalizedY = y / window.innerHeight;
                const decay = 0.1 + normalizedY * 0.4;
                
                oscillator.type = 'sine';
                oscillator.frequency.value = frequency;
                
                // Envelope
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.1, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + decay);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                // Start and stop
                oscillator.start(now);
                oscillator.stop(now + decay);
            }
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.0025);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);

        // Renderer setup - optimized for performance
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false,
            powerPreference: 'high-performance',
            precision: 'mediump'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting - simplified for performance
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);

        const centerLight = new THREE.PointLight(0xffffff, 1, 30);
        centerLight.position.set(0, 5, 0);
        centerLight.castShadow = true;
        centerLight.shadow.mapSize.width = 1024;
        centerLight.shadow.mapSize.height = 1024;
        scene.add(centerLight);

        const leftLight = new THREE.PointLight(0xffcc99, 1, 20);
        leftLight.position.set(-5, 5, 5);
        leftLight.intensity = 0.2;
        scene.add(leftLight);

        const rightLight = new THREE.PointLight(0x99ccff, 1, 20);
        rightLight.position.set(5, 5, 5);
        rightLight.intensity = 0.2;
        scene.add(rightLight);

        const fireLight = new THREE.PointLight(0xff9900, 1.5, 20);
        fireLight.position.set(0, 1, 0);
        scene.add(fireLight);

        // Performance space - the stage
        const stageGeometry = new THREE.BoxGeometry(20, 0.5, 10);
        const stageMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const stage = new THREE.Mesh(stageGeometry, stageMaterial);
        stage.position.y = -0.25;
        stage.receiveShadow = true;
        scene.add(stage);

        // Create more humanoid ritual figures
        function createHumanFigure(posX, name, faceTexturePath) {
            const figureGroup = new THREE.Group();
            
            // Create torso
            const torsoGeometry = new THREE.CylinderGeometry(0.4, 0.3, 1.5, 8);
            const torsoMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.7
            });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.y = 1;
            torso.castShadow = true;
            figureGroup.add(torso);
            
            // Create head with silly face texture
            const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            
            // Create a loader for the face texture
            const textureLoader = new THREE.TextureLoader();
            const faceMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            
            // Load the face texture
            if (faceTexturePath) {
                textureLoader.load(faceTexturePath, (texture) => {
                    faceMaterial.map = texture;
                    faceMaterial.needsUpdate = true;
                });
            }
            
            const head = new THREE.Mesh(headGeometry, faceMaterial);
            head.position.y = 2.1;
            head.castShadow = true;
            figureGroup.add(head);
            
            // Create neck
            const neckGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.3, 8);
            const neckMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.7
            });
            const neck = new THREE.Mesh(neckGeometry, neckMaterial);
            neck.position.y = 1.8;
            neck.castShadow = true;
            figureGroup.add(neck);
            
            // Create legs
            const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 1.2, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.7
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, 0.1, 0);
            leftLeg.castShadow = true;
            figureGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, 0.1, 0);
            rightLeg.castShadow = true;
            figureGroup.add(rightLeg);
            
            // Create arms
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
            const armMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.7
            });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.6, 1.2, 0);
            leftArm.rotation.z = Math.PI / 4;
            leftArm.castShadow = true;
            figureGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.6, 1.2, 0);
            rightArm.rotation.z = -Math.PI / 4;
            rightArm.castShadow = true;
            figureGroup.add(rightArm);
            
            // Add text label
            const textCanvas = document.createElement('canvas');
            textCanvas.width = 256;
            textCanvas.height = 64;
            const textContext = textCanvas.getContext('2d');
            textContext.fillStyle = 'white';
            textContext.font = '32px Times New Roman';
            textContext.textAlign = 'center';
            textContext.textBaseline = 'middle';
            textContext.fillText(name, 128, 32);
            
            const textTexture = new THREE.CanvasTexture(textCanvas);
            const textMaterial = new THREE.MeshBasicMaterial({
                map: textTexture,
                transparent: true,
                side: THREE.DoubleSide
            });
            const textGeometry = new THREE.PlaneGeometry(2, 0.5);
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.y = 3;
            textMesh.rotation.x = -Math.PI / 6;
            figureGroup.add(textMesh);
            
            // Make figure interactive
            figureGroup.userData = {
                isActive: false,
                hoverHeight: 0.2,
                rotationSpeed: 0.01,
                pulseSpeed: 0.5,
                interactive: true,
                name: name
            };
            
            // Add to the scene at specified position
            figureGroup.position.set(posX, 0, 0);
            
            // Add to interactive elements list
            AppState.interactiveElements.push({
                object: figureGroup,
                type: 'figure',
                name: name
            });
            
            return figureGroup;
        }

        // Create figures with silly faces (initially hidden)
        const ethanFigure = createHumanFigure(-5, 'ETHAN', 'assets/faces/ethan.jpg');
        ethanFigure.visible = false;
        scene.add(ethanFigure);

        const noelFigure = createHumanFigure(5, 'NOEL', 'assets/faces/noel.jpg');
        noelFigure.visible = false;
        scene.add(noelFigure);

        // Create central ritual object - optimized
        function createCentralRitual() {
            const ritualGroup = new THREE.Group();
            
            const baseGeometry = new THREE.CylinderGeometry(2, 2, 0.5, 12);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.25;
            base.receiveShadow = true;
            ritualGroup.add(base);
            
            // Create central column - the focal point of our ritual
            const columnGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 12);
            const columnMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.5,
                emissive: 0x333333,
                emissiveIntensity: 0.2
            });
            const column = new THREE.Mesh(columnGeometry, columnMaterial);
            column.position.y = 3;
            column.castShadow = true;
            ritualGroup.add(column);
            
            // Create orbiting rings - visual metaphor for transcendence
            for (let i = 0; i < 2; i++) {
                const ringGeometry = new THREE.TorusGeometry(1.5 - i * 0.3, 0.05, 6, 24);
                const ringMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7 - i * 0.15,
                    emissive: 0xaaaaaa,
                    emissiveIntensity: 0.2
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.y = 2 + i * 1.2;
                ring.userData = {
                    rotationAxis: new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).normalize(),
                    rotationSpeed: 0.005 + Math.random() * 0.01
                };
                ritualGroup.add(ring);
            }
            
            // Create floating symbols - representing key concepts from the manifesto
            const symbolCount = 5;
            for (let i = 0; i < symbolCount; i++) {
                const angle = (i / symbolCount) * Math.PI * 2;
                const radius = 1.8;
                
                // Create different geometric forms for visual interest
                let symbolGeometry;
                switch(i % 3) {
                    case 0: 
                        symbolGeometry = new THREE.TetrahedronGeometry(0.2);
                        break;
                    case 1:
                        symbolGeometry = new THREE.OctahedronGeometry(0.15);
                        break;
                    case 2:
                        symbolGeometry = new THREE.IcosahedronGeometry(0.18);
                        break;
                }
                
                const symbolMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    emissive: 0xaaaaaa,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
                symbol.position.set(
                    Math.cos(angle) * radius,
                    2 + Math.random() * 3,
                    Math.sin(angle) * radius
                );
                symbol.userData = {
                    orbitSpeed: 0.01 + Math.random() * 0.02,
                    orbitRadius: radius,
                    orbitCenterY: symbol.position.y,
                    startAngle: angle,
                    pulseSpeed: 0.5 + Math.random(),
                    interactive: true
                };
                
                // Add to interactive elements
                AppState.interactiveElements.push({
                    object: symbol,
                    type: 'symbol',
                    name: `Ritual Symbol ${i+1}`
                });
                
                ritualGroup.add(symbol);
            }
            
            // Create a subtle pulsing aura - the energetic field of the ritual
            const auraGeometry = new THREE.SphereGeometry(2.5, 16, 16);
            const auraTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==');
            const auraMaterial = new THREE.MeshBasicMaterial({
                map: auraTexture,
                color: 0xffffff,
                transparent: true,
                opacity: 0.1,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            aura.position.y = 2;
            aura.userData = { pulseSpeed: 0.3 };
            ritualGroup.add(aura);
            
            // Make central ritual interactive
            ritualGroup.userData = {
                interactive: true,
                name: "Central Ritual"
            };
            
            // Add to interactive elements
            AppState.interactiveElements.push({
                object: ritualGroup,
                type: 'ritual',
                name: "Central Ritual"
            });
            
            return ritualGroup;
        }

        const centralRitual = createCentralRitual();
        scene.add(centralRitual);

        // Create particle system - optimized
        function createParticleSystem(count) {
            // Reduce particle count based on quality level
            count = Math.floor(count * (AppState.qualityLevel / 3));
            
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const colors = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                // Position particles in a sphere around the ritual
                const radius = 10 + Math.random() * 5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta) - 2;
                positions[i3 + 2] = radius * Math.cos(phi);
                
                // Set random velocities for organic movement
                velocities[i3] = (Math.random() - 0.5) * 0.01;
                velocities[i3 + 1] = (Math.random() - 0.5) * 0.01;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
                
                // Vary particle sizes for depth and visual interest
                sizes[i] = 0.03 + Math.random() * 0.05;
                
                // Create subtle color variations based on soundscape
                let hue;
                switch (AppState.soundMode) {
                    case 'ambient': hue = 0.6; break; // Blue
                    case 'ritual': hue = 0.8; break;  // Purple
                    case 'cosmic': hue = 0.1; break;  // Gold
                    default: hue = Math.random();
                }
                
                const colorObject = new THREE.Color().setHSL(hue, 0.5, 0.7);
                colors[i3] = colorObject.r;
                colors[i3 + 1] = colorObject.g;
                colors[i3 + 2] = colorObject.b;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Simplified particle material
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            particleSystem.userData = { 
                velocities: velocities,
                sizes: sizes,
                colors: colors,
                time: 0
            };
            
            return particleSystem;
        }

        // Create optimized particle system
        const particleSystem = createParticleSystem(800);
        scene.add(particleSystem);

        // Create floating text planes with manifesto excerpts
        function createFloatingTextPlanes() {
            const textGroup = new THREE.Group();
            
            // Split manifesto into chunks
            const manifestoChunks = manifestoText.split(/\n+/).filter(chunk => chunk.trim().length > 0);
            
            // Limit the number of text planes based on quality level
            const planeCount = Math.min(manifestoChunks.length, 5 + AppState.qualityLevel * 3);
            
            for (let i = 0; i < planeCount; i++) {
                const chunk = manifestoChunks[i];
                
                // Create a canvas for the text rendering
                const textCanvas = document.createElement('canvas');
                textCanvas.width = 256;
                textCanvas.height = 128;
                const textContext = textCanvas.getContext('2d');
                
                // Create a subtle gradient background
                const gradient = textContext.createLinearGradient(0, 0, 0, 128);
                gradient.addColorStop(0, 'rgba(40, 40, 40, 0.6)');
                gradient.addColorStop(1, 'rgba(20, 20, 20, 0.2)');
                textContext.fillStyle = gradient;
                textContext.fillRect(0, 0, 256, 128);
                
                // Style the text with artistic typography
                textContext.fillStyle = 'white';
                textContext.font = '16px Times New Roman';
                textContext.textAlign = 'center';
                textContext.textBaseline = 'middle';
                
                // Simplify text for better performance and readability
                const shortChunk = chunk.length > 100 ? chunk.substring(0, 100) + "..." : chunk;
                textContext.fillText(shortChunk, 128, 64);
                
                // Create the texture from our canvas
                const textTexture = new THREE.CanvasTexture(textCanvas);
                const textMaterial = new THREE.MeshBasicMaterial({
                    map: textTexture,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const textGeometry = new THREE.PlaneGeometry(5, 1.25);
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                
                // Position the text planes in a dynamic arrangement
                const radius = 8 + Math.random() * 5;
                const angle = (i / planeCount) * Math.PI * 2;
                const height = -3 + Math.sin(i * 0.5) * 8;
                
                textMesh.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                // Rotate to face center for better readability
                textMesh.lookAt(0, height, 0);
                
                // Add animation data
                textMesh.userData = {
                    orbitSpeed: 0.001 + Math.random() * 0.003,
                    orbitRadius: radius,
                    orbitCenterY: height,
                    startAngle: angle,
                    pulseSpeed: 0.2 + Math.random() * 0.3,
                    originalScale: 1.0,
                    interactive: true,
                    textContent: shortChunk
                };
                
                // Add to interactive elements
                AppState.interactiveElements.push({
                    object: textMesh,
                    type: 'text',
                    name: `Manifesto Fragment ${i+1}`,
                    content: shortChunk
                });
                
                textGroup.add(textMesh);
            }
            
            return textGroup;
        }

        const floatingTexts = createFloatingTextPlanes();
        scene.add(floatingTexts);

        // Variables for camera control
        let previousCameraPosition = new THREE.Vector3();
        let targetCameraPosition = new THREE.Vector3();
        let previousCameraLookAt = new THREE.Vector3(0, 2, 0);
        let targetCameraLookAt = new THREE.Vector3(0, 2, 0);

        // Function to transition camera to a new mode
        function transitionCameraToMode(newMode) {
            // Store current camera position and target
            previousCameraPosition.copy(camera.position);
            
            // Get current camera lookAt target
            const currentMatrix = new THREE.Matrix4();
            currentMatrix.extractRotation(camera.matrix);
            const dir = new THREE.Vector3(0, 0, -1);
            dir.applyMatrix4(currentMatrix);
            dir.multiplyScalar(10);
            previousCameraLookAt.copy(camera.position).add(dir);
            
            // Set target position based on new mode
            if (newMode === 'orbit') {
                const angle = Math.random() * Math.PI * 2;
                targetCameraPosition.set(
                    Math.sin(angle) * 15,
                    5 + Math.random() * 2,
                    Math.cos(angle) * 15
                );
                targetCameraLookAt.set(0, 2, 0);
            } else if (newMode === 'focus-ethan') {
                const angle = Math.random() * Math.PI * 2;
                targetCameraPosition.set(
                    ethanFigure.position.x + Math.sin(angle) * 4,
                    3 + Math.random(),
                    ethanFigure.position.z + Math.cos(angle) * 4
                );
                targetCameraLookAt.set(ethanFigure.position.x, ethanFigure.position.y + 3, ethanFigure.position.z);
            } else if (newMode === 'focus-noel') {
                const angle = Math.random() * Math.PI * 2;
                targetCameraPosition.set(
                    noelFigure.position.x + Math.sin(angle) * 4,
                    3 + Math.random(),
                    noelFigure.position.z + Math.cos(angle) * 4
                );
                targetCameraLookAt.set(noelFigure.position.x, noelFigure.position.y + 3, noelFigure.position.z);
            } else if (newMode === 'ritual-close') {
                const angle = Math.random() * Math.PI * 2;
                targetCameraPosition.set(
                    Math.sin(angle) * 3,
                    2 + Math.random() * 1,
                    Math.cos(angle) * 3
                );
                targetCameraLookAt.set(0, 2.5, 0);
            }
            
            // Start transition
            AppState.cameraMode = newMode;
            AppState.cameraTransitioning = true;
            AppState.cameraTweenProgress = 0;
            
            // Play transition sound
            if (AudioSystem.context) {
                AudioSystem.playRandomTone(AppState.soundMode);
            }
            
            // Create visual transition effect
            createCameraTransitionEffect();
        }

        // Create a visual effect for camera transitions
        function createCameraTransitionEffect() {
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = 'rgba(255,255,255,0.2)';
            flash.style.zIndex = '5';
            flash.style.opacity = '0.7';
            flash.style.transition = 'opacity 1s';
            flash.style.pointerEvents = 'none';
            document.body.appendChild(flash);
            
            setTimeout(() => {
                flash.style.opacity = '0';
                setTimeout(() => flash.remove(), 1000);
            }, 100);
        }

        // Cubic easing function for smooth camera transitions
        function cubicEaseInOut(t) {
            return t < 0.5
                ? 4 * t * t * t
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Update particle system with optimized approach
        function updateParticleSystem(system, delta) {
            // Skip updates when not visible
            if (!AppState.ritualActive) return;
            
            const positions = system.geometry.attributes.position.array;
            const velocities = system.userData.velocities;
            
            // Only update a subset of particles each frame for performance
            const updateCount = Math.min(positions.length / 3, 200);
            const startIndex = Math.floor(Math.random() * (positions.length / 3 - updateCount)) * 3;
            
            for (let i = startIndex; i < startIndex + updateCount * 3; i += 3) {
                // Update particle positions
                positions[i] += velocities[i] * delta * 60;
                positions[i + 1] += velocities[i + 1] * delta * 60;
                positions[i + 2] += velocities[i + 2] * delta * 60;
                
                // Contain particles within a sphere
                const distance = Math.sqrt(
                    positions[i] * positions[i] + 
                    positions[i + 1] * positions[i + 1] + 
                    positions[i + 2] * positions[i + 2]
                );
                
                if (distance > 15) {
                    // Reset particles that go too far
                    const scale = 15 / distance;
                    positions[i] *= scale;
                    positions[i + 1] *= scale;
                    positions[i + 2] *= scale;
                    
                    // Reverse velocity with some randomness
                    velocities[i] = -velocities[i] * 0.8 + (Math.random() - 0.5) * 0.01;
                    velocities[i + 1] = -velocities[i + 1] * 0.8 + (Math.random() - 0.5) * 0.01;
                    velocities[i + 2] = -velocities[i + 2] * 0.8 + (Math.random() - 0.5) * 0.01;
                }
            }
            
            system.geometry.attributes.position.needsUpdate = true;
        }

        // Create visual effects
        function renderVisualEffects(time) {
            const width = effectsCanvas.width;
            const height = effectsCanvas.height;
            
            // Clear canvas
            effectsCtx.clearRect(0, 0, width, height);
            
            // Only render effects when ritual is active
            if (!AppState.ritualActive) return;
            
            // Film grain - adds tactile quality and depth
            const grainOpacity = 0.03;
            effectsCtx.fillStyle = `rgba(0, 0, 0, ${grainOpacity})`;
            
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const size = Math.random() * 2;
                effectsCtx.fillRect(x, y, size, size);
            }
            
            // Scan lines - creates a retro, analog feel
            effectsCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            for (let y = 0; y < height; y += 4) {
                effectsCtx.fillRect(0, y + 2, width, 1);
            }
            
            // Vignette - focuses attention on the center
            const gradient = effectsCtx.createRadialGradient(
                width / 2, height / 2, 0,
                width / 2, height / 2, width / 2
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
            
            effectsCtx.fillStyle = gradient;
            effectsCtx.fillRect(0, 0, width, height);
            
            // Add subtle color tint based on current soundscape
            let tintColor;
            switch (AppState.soundMode) {
                case 'ambient': tintColor = 'rgba(0, 50, 100, 0.05)'; break; // Blue
                case 'ritual': tintColor = 'rgba(100, 0, 100, 0.05)'; break; // Purple
                case 'cosmic': tintColor = 'rgba(100, 80, 0, 0.05)'; break;  // Gold
                default: tintColor = 'rgba(0, 0, 0, 0)';
            }
            
            effectsCtx.fillStyle = tintColor;
            effectsCtx.fillRect(0, 0, width, height);
        }

        // Animation loop - optimized
        function animate(timestamp) {
            requestAnimationFrame(animate);
            
            // Calculate delta time
            const delta = timestamp - AppState.previousFrameTime || 0;
            AppState.previousFrameTime = timestamp;
            const deltaSeconds = delta * 0.001;
            
            // FPS calculation
            AppState.frameCount++;
            if (timestamp - AppState.lastFpsUpdate > 1000) {
                AppState.frameRate = AppState.frameCount;
                AppState.frameCount = 0;
                AppState.lastFpsUpdate = timestamp;
                
                // Adjust quality based on frame rate
                if (AppState.ritualActive) {
                    if (AppState.frameRate < 30 && AppState.qualityLevel > 1) {
                        AppState.qualityLevel--;
                    } else if (AppState.frameRate > 55 && AppState.qualityLevel < 3) {
                        AppState.qualityLevel++;
                    }
                }
            }
            
            // Only update time when ritual is active
            if (AppState.ritualActive) {
                AppState.elapsedTime += deltaSeconds;
                
                // Update timer display
                const hours = Math.floor(AppState.elapsedTime / 3600).toString().padStart(2, '0');
                const minutes = Math.floor((AppState.elapsedTime % 3600) / 60).toString().padStart(2, '0');
                const seconds = Math.floor(AppState.elapsedTime % 60).toString().padStart(2, '0');
                elements.timer.textContent = `${hours}:${minutes}:${seconds} / 72:00:00`;
                
                // Animate central ritual
                centralRitual.children.forEach(child => {
                    if (child.userData.rotationAxis) {
                        // Rotate rings around their custom axes
                        child.rotateOnAxis(child.userData.rotationAxis, child.userData.rotationSpeed);
                    }
                    
                    if (child.userData.orbitSpeed) {
                        // Orbit symbols around the center
                        const newAngle = child.userData.startAngle + AppState.elapsedTime * child.userData.orbitSpeed;
                        child.position.x = Math.cos(newAngle) * child.userData.orbitRadius;
                        child.position.z = Math.sin(newAngle) * child.userData.orbitRadius;
                        
                        // Add slight up/down motion
                        child.position.y = child.userData.orbitCenterY + 
                            Math.sin(AppState.elapsedTime * child.userData.pulseSpeed) * 0.2;
                    }
                    
                    if (child.userData.pulseSpeed) {
                        // Pulse the aura
                        const scale = 1 + Math.sin(AppState.elapsedTime * child.userData.pulseSpeed) * 0.1;
                        child.scale.set(scale, scale, scale);
                    }
                });
                
                // Animate figures if they're active
                [ethanFigure, noelFigure].forEach(figure => {
                    if (figure.visible) {
                        // Hovering motion
                        figure.position.y = Math.sin(AppState.elapsedTime * figure.userData.pulseSpeed) * figure.userData.hoverHeight;
                        
                        // Slow rotation
                        figure.rotation.y += figure.userData.rotationSpeed;
                        
                        // Animate breathing effect on torso
                        const torso = figure.children.find(child => 
                            child.geometry && child.geometry.type === 'CylinderGeometry' && 
                            child.position.y === 1);
                        
                        if (torso) {
                            const breathScale = 1 + Math.sin(AppState.elapsedTime * 0.5) * 0.05;
                            torso.scale.x = breathScale;
                            torso.scale.z = breathScale;
                        }
                        
                        // Animate arms slightly
                        const leftArm = figure.children.find(child => 
                            child.position.x < 0 && child.rotation.z > 0);
                        const rightArm = figure.children.find(child => 
                            child.position.x > 0 && child.rotation.z < 0);
                            
                        if (leftArm) {
                            leftArm.rotation.z = Math.PI / 4 + Math.sin(AppState.elapsedTime * 0.3) * 0.1;
                        }
                        
                        if (rightArm) {
                            rightArm.rotation.z = -Math.PI / 4 - Math.sin(AppState.elapsedTime * 0.3) * 0.1;
                        }
                    }
                });
                
                // Animate floating text planes
                floatingTexts.children.forEach(textPlane => {
                    // Orbit around the center
                    const newAngle = textPlane.userData.startAngle + AppState.elapsedTime * textPlane.userData.orbitSpeed;
                    textPlane.position.x = Math.cos(newAngle) * textPlane.userData.orbitRadius;
                    textPlane.position.z = Math.sin(newAngle) * textPlane.userData.orbitRadius;
                    
                    // Subtle vertical motion
                    textPlane.position.y = textPlane.userData.orbitCenterY + 
                        Math.sin(AppState.elapsedTime * textPlane.userData.pulseSpeed) * 0.3;
                    
                    // Always face the camera for readability
                    textPlane.lookAt(camera.position);
                });
                
                // Update particle system - throttled
                if (AppState.frameCount % 2 === 0) {
                    updateParticleSystem(particleSystem, deltaSeconds);
                }
                
                // Update fire light intensity
                fireLight.intensity = 1.2 + Math.sin(AppState.elapsedTime * 3) * 0.3;
            }
            
            // Camera movement based on mode
            if (AppState.cameraTransitioning) {
                // Smooth transition between camera positions
                AppState.cameraTweenProgress = Math.min(1, AppState.cameraTweenProgress + deltaSeconds * 2);
                
                // Use cubic easing for natural movement
                const t = cubicEaseInOut(AppState.cameraTweenProgress);
                
                // Interpolate position
                camera.position.lerpVectors(previousCameraPosition, targetCameraPosition, t);
                
                // Interpolate lookAt
                const currentLookAt = new THREE.Vector3();
                currentLookAt.lerpVectors(previousCameraLookAt, targetCameraLookAt, t);
                camera.lookAt(currentLookAt);
                
                // End transition
                if (AppState.cameraTweenProgress >= 1) {
                    AppState.cameraTransitioning = false;
                }
            } else {
                // Regular camera movement based on mode
                if (AppState.cameraMode === 'orbit') {
                    // Standard orbit with gentle vertical movement
                    camera.position.x = Math.sin(AppState.elapsedTime * 0.05) * 15;
                    camera.position.z = Math.cos(AppState.elapsedTime * 0.05) * 15;
                    camera.position.y = 5 + Math.sin(AppState.elapsedTime * 0.02) * 2;
                    camera.lookAt(0, 2, 0);
                } else if (AppState.cameraMode === 'focus-ethan') {
                    // Focus on Ethan with gentle orbital movement
                    const orbitRadius = 4;
                    const orbitSpeed = 0.1;
                    camera.position.x = ethanFigure.position.x + Math.sin(AppState.elapsedTime * orbitSpeed) * orbitRadius;
                    camera.position.z = ethanFigure.position.z + Math.cos(AppState.elapsedTime * orbitSpeed) * orbitRadius;
                    camera.position.y = 3 + Math.sin(AppState.elapsedTime * 0.2) * 0.5;
                    
                    // Look at Ethan's head position
                    const lookTarget = new THREE.Vector3(
                        ethanFigure.position.x,
                        ethanFigure.position.y + 3 + Math.sin(AppState.elapsedTime * 0.5) * 0.2,
                        ethanFigure.position.z
                    );
                    camera.lookAt(lookTarget);
                } else if (AppState.cameraMode === 'focus-noel') {
                    // Focus on Noel with gentle orbital movement
                    const orbitRadius = 4;
                    const orbitSpeed = 0.1;
                    camera.position.x = noelFigure.position.x + Math.sin(AppState.elapsedTime * orbitSpeed) * orbitRadius;
                    camera.position.z = noelFigure.position.z + Math.cos(AppState.elapsedTime * orbitSpeed) * orbitRadius;
                    camera.position.y = 3 + Math.sin(AppState.elapsedTime * 0.2) * 0.5;
                    
                    // Look at Noel's head position
                    const lookTarget = new THREE.Vector3(
                        noelFigure.position.x,
                        noelFigure.position.y + 3 + Math.sin(AppState.elapsedTime * 0.5) * 0.2,
                        noelFigure.position.z
                    );
                    camera.lookAt(lookTarget);
                } else if (AppState.cameraMode === 'ritual-close') {
                    // Dramatic close-up of the central ritual - creates intimacy with the core experience
                    const radius = 3 + Math.sin(AppState.elapsedTime * 0.1) * 0.5;
                    const height = 2 + Math.sin(AppState.elapsedTime * 0.08) * 1;
                    const angle = AppState.elapsedTime * 0.03;
                    
                    camera.position.x = Math.sin(angle) * radius;
                    camera.position.z = Math.cos(angle) * radius;
                    camera.position.y = height;
                    
                    // Look at the center of the ritual
                    camera.lookAt(0, 2.5 + Math.sin(AppState.elapsedTime * 0.2) * 0.3, 0);
                }
            }
            
            // Occasionally change camera mode for visual interest and narrative flow
            if (AppState.ritualActive && Math.random() < 0.0005) {
                const modes = ['orbit', 'focus-ethan', 'focus-noel', 'ritual-close'];
                const newMode = modes[Math.floor(Math.random() * modes.length)];
                
                // Don't transition to the same mode
                if (newMode !== AppState.cameraMode) {
                    transitionCameraToMode(newMode);
                }
            }
            
            // Update center light color based on ritual progression - visual metaphor for transformation
            const ritualProgress = Math.min(1, AppState.elapsedTime / (72 * 3600)); // 72 hours max
            const hue = ritualProgress * 0.5; // Shift from red to blue-green
            centerLight.color.setHSL(hue, 0.7, 0.5);
            
            // Render visual effects - creates atmosphere and depth
            renderVisualEffects(AppState.elapsedTime);
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Handle window resize - ensures responsive design
        function handleResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            resizeCanvases();
        }

        window.addEventListener('resize', handleResize);

        // Check for interactions with 3D objects - creates engagement through interactivity
        function checkInteractions(event) {
            if (!AppState.ritualActive) return;
            
            // Calculate mouse position in normalized device coordinates
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Create raycaster
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Get all interactive objects
            const interactiveObjects = AppState.interactiveElements.map(item => item.object);
            
            // Check for intersections
            const intersects = raycaster.intersectObjects(interactiveObjects, true);
            
            if (intersects.length > 0) {
                // Find the interactive parent object
                let interactiveObject = intersects[0].object;
                while (interactiveObject && !interactiveObject.userData.interactive) {
                    interactiveObject = interactiveObject.parent;
                }
                
                if (interactiveObject) {
                    // Find the element info
                    const elementInfo = AppState.interactiveElements.find(item => 
                        item.object === interactiveObject);
                    
                    if (elementInfo) {
                        // Play interaction sound based on position
                        if (AudioSystem.context) {
                            AudioSystem.playClickSound(event.clientX, event.clientY);
                        }
                        
                        // Handle interaction based on type
                        switch (elementInfo.type) {
                            case 'figure':
                                // Focus camera on the figure
                                transitionCameraToMode(elementInfo.name === 'ETHAN' ? 'focus-ethan' : 'focus-noel');
                                
                                // Add to text portal
                                addTextPortalEntry(elementInfo.name, 
                                    `Interaction with ${elementInfo.name} has revealed new insights into the ritual process.`);
                                break;
                                
                            case 'ritual':
                                // Focus on ritual
                                transitionCameraToMode('ritual-close');
                                
                                // Change soundscape
                                if (AudioSystem.context) {
                                    AudioSystem.createRitualSoundscape();
                                }
                                
                                // Add to text portal
                                addTextPortalEntry("RITUAL CORE", 
                                    "The central ritual emanates with transformative energy. The art worker shall create. The art worker shall love.");
                                break;
                                
                            case 'symbol':
                                // Create visual effect
                                createSymbolInteractionEffect(interactiveObject.position);
                                
                                // Add to text portal
                                addTextPortalEntry("SYMBOL RESONANCE", 
                                    "This symbol represents the rejection of binary oppositions. How absence speaks? How to touch without touching?");
                                break;
                                
                            case 'text':
                                // Show text in portal
                                if (elementInfo.content) {
                                    addTextPortalEntry("MANIFESTO FRAGMENT", elementInfo.content);
                                }
                                break;
                        }
                        
                        // Show text portal if not already visible
                        if (!AppState.textPortalActive) {
                            toggleTextPortal(true);
                        }
                        
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Create visual effect for symbol interaction
        function createSymbolInteractionEffect(position) {
            // Create particles emanating from symbol
            const particleCount = 20;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleColors = new Float32Array(particleCount * 3);
            
            // Set initial positions at the symbol position
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                particlePositions[i3] = position.x;
                particlePositions[i3 + 1] = position.y;
                particlePositions[i3 + 2] = position.z;
                
                // Set colors based on current soundscape
                let hue;
                switch (AppState.soundMode) {
                    case 'ambient': hue = 0.6; break; // Blue
                    case 'ritual': hue = 0.8; break;  // Purple
                    case 'cosmic': hue = 0.1; break;  // Gold
                    default: hue = Math.random();
                }
                
                const color = new THREE.Color().setHSL(hue, 0.7, 0.7);
                particleColors[i3] = color.r;
                particleColors[i3 + 1] = color.g;
                particleColors[i3 + 2] = color.b;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Create velocities for particles
            const velocities = [];
            for (let i = 0; i < particleCount; i++) {
                velocities.push({
                    x: (Math.random() - 0.5) * 0.1,
                    y: (Math.random() - 0.5) * 0.1 + 0.05,
                    z: (Math.random() - 0.5) * 0.1
                });
            }
            
            // Animate particles
            let lifetime = 0;
            function animateParticles() {
                lifetime += 0.02;
                
                const positions = particles.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    positions[i3] += velocities[i].x;
                    positions[i3 + 1] += velocities[i].y;
                    positions[i3 + 2] += velocities[i].z;
                    
                    // Add gravity
                    velocities[i].y -= 0.001;
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                
                // Fade out
                particles.material.opacity = Math.max(0, 0.8 - lifetime);
                
                if (lifetime < 2) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                    particles.geometry.dispose();
                    particles.material.dispose();
                }
            }
            
            animateParticles();
        }

        // Add entry to text portal
        function addTextPortalEntry(title, content) {
            const entryDiv = document.createElement('div');
            entryDiv.className = 'text-portal-entry';
            
            const titleElement = document.createElement('h3');
            titleElement.textContent = title;
            entryDiv.appendChild(titleElement);
            
            const contentElement = document.createElement('p');
            contentElement.textContent = content;
            entryDiv.appendChild(contentElement);
            
            // Add timestamp
            const timestamp = document.createElement('small');
            const timeString = new Date().toLocaleTimeString();
            timestamp.textContent = `Recorded at ${timeString}`;
            timestamp.style.color = '#aaa';
            timestamp.style.display = 'block';
            timestamp.style.marginTop = '10px';
            entryDiv.appendChild(timestamp);
            
            // Insert at the beginning
            if (elements.textPortal.children.length > 1) {
                elements.textPortal.insertBefore(entryDiv, elements.textPortal.children[1]);
            } else {
                elements.textPortal.appendChild(entryDiv);
            }
            
            // Limit number of entries to prevent performance issues
            const entries = elements.textPortal.querySelectorAll('.text-portal-entry');
            if (entries.length > 10) {
                entries[entries.length - 1].remove();
            }
        }

        // Toggle text portal visibility
        function toggleTextPortal(show) {
            if (show) {
                elements.textPortal.classList.add('active');
                AppState.textPortalActive = true;
            } else {
                elements.textPortal.classList.remove('active');
                AppState.textPortalActive = false;
            }
        }

        // Button event handlers
        document.getElementById('ethan-button').addEventListener('click', () => {
            // Create anticipation with button animation
            const button = document.getElementById('ethan-button');
            button.style.transform = 'scale(0.95)';
            setTimeout(() => button.style.transform = '', 200);

            window.location.href='pages/ethan.html';
        });

        document.getElementById('noel-button').addEventListener('click', () => {
            // Create anticipation with button animation
            const button = document.getElementById('noel-button');
            button.style.transform = 'scale(0.95)';
            setTimeout(() => button.style.transform = '', 200);

            window.location.href='pages/noel.html';
        });

        // Main ritual entry handler
        document.getElementById('enter-ritual').addEventListener('click', () => {
            // Create anticipation with button animation
            const button = document.getElementById('enter-ritual');
            button.style.transform = 'scale(0.95)';
            setTimeout(() => button.style.transform = '', 200);
            
            // Hide portal with dramatic transition
            elements.portalContainer.classList.add('hidden');
            
            // Create dramatic entrance effect - sets the tone for the experience
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = 'white';
            flash.style.zIndex = '50';
            flash.style.opacity = '1';
            flash.style.transition = 'opacity 3s';
            document.body.appendChild(flash);
            
            setTimeout(() => {
                flash.style.opacity = '0';
                setTimeout(() => flash.remove(), 3000);
            }, 100);
            
            // Start with both figures visible
            ethanFigure.visible = true;
            noelFigure.visible = true;
            leftLight.intensity = 1.0;
            rightLight.intensity = 1.0;
            
            // Reset timer
            AppState.elapsedTime = 0;
            
            // Mark ritual as active
            AppState.ritualActive = true;
            
            // Show controls hint and return button
            elements.controls.style.opacity = '0.8';
            setTimeout(() => elements.controls.style.opacity = '0', 5000);
            
            elements.returnButton.classList.remove('hidden');
            
            // Initialize audio and start ambient soundscape
            AudioSystem.initialize();
            AudioSystem.createAmbientSoundscape();
            
            // Show audio controls
            elements.audioControls.style.display = 'flex';
            
            // Show ritual artifacts
            elements.ritualArtifacts.classList.remove('hidden');
            
            // Add initial text portal entry
            addTextPortalEntry("RITUAL INITIATED", 
                "The 72-hour transcendent ritual has begun. Reject binary oppositions. The art worker shall create.");
            
            // Start with random camera mode for visual interest
            const initialModes = ['orbit', 'ritual-close'];
            transitionCameraToMode(initialModes[Math.floor(Math.random() * initialModes.length)]);
        });

        // Return to portal handler
        document.getElementById('return-button').addEventListener('click', returnToPortal);

        function returnToPortal() {
            // Create exit transition
            const fade = document.createElement('div');
            fade.style.position = 'fixed';
            fade.style.top = '0';
            fade.style.left = '0';
            fade.style.width = '100%';
            fade.style.height = '100%';
            fade.style.backgroundColor = 'black';
            fade.style.zIndex = '50';
            fade.style.opacity = '0';
            fade.style.transition = 'opacity 2s';
            document.body.appendChild(fade);
            
            fade.offsetHeight; // Force reflow
            fade.style.opacity = '1';
            
            setTimeout(() => {
                // Show portal again
                elements.portalContainer.classList.remove('hidden');
                elements.returnButton.classList.add('hidden');
                
                // Hide figures
                ethanFigure.visible = false;
                noelFigure.visible = false;
                leftLight.intensity = 0.2;
                rightLight.intensity = 0.2;
                
                // Mark ritual as inactive
                AppState.ritualActive = false;
                
                // Hide audio controls
                elements.audioControls.style.display = 'none';
                
                // Stop all sounds
                if (AudioSystem.context) {
                    AudioSystem.stopAllSounds();
                }
                
                // Hide text portal
                toggleTextPortal(false);
                
                // Fade out
                fade.style.opacity = '0';
                setTimeout(() => fade.remove(), 2000);
            }, 2000);
        }

        // Enable keyboard controls
        function enableKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                // Only respond when ritual is active
                if (!AppState.ritualActive) return;
                
                if (event.key === '1') {
                    transitionCameraToMode('orbit');
                } else if (event.key === '2') {
                    transitionCameraToMode('focus-ethan');
                } else if (event.key === '3') {
                    transitionCameraToMode('focus-noel');
                } else if (event.key === '4') {
                    transitionCameraToMode('ritual-close');
                } else if (event.key === 'Escape') {
                    if (AppState.textPortalActive) {
                        toggleTextPortal(false);
                    } else {
                        returnToPortal();
                    }
                }
            });
        }

        enableKeyboardControls();

        // About panel toggle
        elements.aboutLink.addEventListener('click', function() {
            elements.aboutPanel.style.display = 'block';
        });

        // Sound toggle
        document.getElementById('toggle-sound').addEventListener('click', function() {
            const soundEnabled = this.getAttribute('data-sound-enabled') !== 'false';
            
            if (soundEnabled) {
                // Mute sound
                if (AudioSystem.context) {
                    AudioSystem.context.suspend();
                }
                document.getElementById('sound-icon').textContent = '🔇';
                this.setAttribute('data-sound-enabled', 'false');
            } else {
                // Unmute sound
                if (AudioSystem.context) {
                    AudioSystem.context.resume();
                }
                document.getElementById('sound-icon').textContent = '🔊';
                this.setAttribute('data-sound-enabled', 'true');
            }
        });

        // Soundscape buttons
        document.getElementById('ambient-sound').addEventListener('click', function() {
            if (AudioSystem.context) {
                AudioSystem.createAmbientSoundscape();
            }
        });

        document.getElementById('ritual-sound').addEventListener('click', function() {
            if (AudioSystem.context) {
                AudioSystem.createRitualSoundscape();
            }
        });

        document.getElementById('cosmic-sound').addEventListener('click', function() {
            if (AudioSystem.context) {
                AudioSystem.createCosmicSoundscape();
            }
        });

        // Text portal close button
        elements.textPortalClose.addEventListener('click', function() {
            toggleTextPortal(false);
        });

        // Add click handler for scene interaction
        renderer.domElement.addEventListener('click', checkInteractions);

        // Check ritual progress for credits
        function checkRitualProgress() {
            if (!AppState.ritualActive) return;
            
            const ritualProgress = AppState.elapsedTime / (72 * 3600); // 72 hours max
            
            if (ritualProgress >= 1) {
                // Show credits
                elements.credits.style.opacity = '1';
                elements.credits.style.pointerEvents = 'auto';
                
                // Reset ritual after credits
                setTimeout(() => {
                    elements.credits.style.opacity = '0';
                    elements.credits.style.pointerEvents = 'none';
                    
                    // Return to portal
                    returnToPortal();
                }, 10000);
                
                return;
            }
            
            // Check again in 10 seconds
            setTimeout(checkRitualProgress, 10000);
        }

        // Reveal ritual symbols
        function revealRitualSymbols() {
            if (!AppState.ritualActive) return;
            
            const symbols = document.querySelectorAll('.ritual-symbol');
            
            // Randomly reveal symbols
            if (Math.random() < 0.05) {
                const randomIndex = Math.floor(Math.random() * symbols.length);
                const symbol = symbols[randomIndex];
                
                // Only show if currently hidden
                if (symbol.style.opacity === '0') {
                    symbol.style.opacity = '1';
                    
                    // Hide after a random duration
                    setTimeout(() => {
                        symbol.style.opacity = '0';
                    }, 5000 + Math.random() * 10000);
                }
            }
            
            // Check again after a random interval
            setTimeout(revealRitualSymbols, 10000 + Math.random() * 20000);
        }

        // Preload critical assets
        function preloadAssets() {
            const images = [
                'assets/backgrounds/marble.jpg',
                'assets/backgrounds/marble.gif',
                'under_construction.gif',
                'symbol1.gif',
                'symbol2.gif',
                'symbol3.gif',
                'netscape.gif',
                'midi.gif',
                'assets/faces/ethan.jpg',
                'assets/faces/noel.jpg'
            ];
            
            images.forEach(src => {
                const img = new Image();
                img.src = src;
            });
        }

        // Initialize page
        function init() {
            // Fade out page transition
            setTimeout(() => {
                elements.pageTransition.style.opacity = '0';
            }, 500);
            
            // Preload assets
            preloadAssets();
            
            // Start animation loop
            animate(0);
            
            // Start ritual elements when ritual begins
            document.getElementById('enter-ritual').addEventListener('click', function() {
                setTimeout(revealRitualSymbols, 30000); // Start after 30 seconds
                setTimeout(checkRitualProgress, 10000);
            });
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
